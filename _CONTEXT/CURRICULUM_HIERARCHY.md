# ProgramPrimitives Curriculum Hierarchy

> **The Core Vision:** You don't become a master craftsman by buying better tools â€” you **earn** refined tools through mastery of the basics.

---

## ğŸ¯ Core Philosophy

**There are coding tools that are used across every coding language. The difference across languages is syntax, but the principles of use persist. We teach tool use, best practices, and principles that users can then practice in the language of their choice.**

### What This Means

| Concept | Our Approach |
|---------|--------------|
| **Tools Are Universal** | A `for` loop, a conditional, a function â€” these exist in *every* language |
| **Syntax Is Secondary** | JavaScript's `for (let i = 0; ...)` vs Python's `for i in range(...)` â€” same tool, different syntax |
| **Principles Persist** | "Avoid off-by-one errors", "use guard clauses for readability" â€” true everywhere |
| **Practice in Your Language** | Learn the concept once, apply it in JS, Python, Go, Rust, or any language you choose |

### The Learning Flow

```
1. UNDERSTAND THE TOOL (Blueprints)
   "What is a for loop? Why does it exist? What problems does it solve?"
   â””â”€â”€ Language-agnostic explanation, mental models, principles
   
2. SEE THE PATTERNS (Best Practices)
   "When should I use a for loop vs forEach vs map?"
   â””â”€â”€ Universal decision-making frameworks
   
3. LEARN THE SYNTAX (Per Language)
   "How do I write a for loop in JavaScript?"
   â””â”€â”€ Language-specific syntax, idioms, gotchas
   
4. PRACTICE & APPLY
   "Complete exercises in your chosen language"
   â””â”€â”€ Targeted feedback based on tool mastery AND syntax fluency
```

---

## Blueprints

ProgramPrimitives teaches **universal programming tools and strategies** that transcend any single language. We focus on the fundamental building blocks every developer uses to solve problems.

### The Craftsman's Journey

Just as a craftsman progresses from crude implements to precision instruments, developers refine their tools through mastery:

```
ğŸ“ BLUEPRINTS     Understanding the why, planning the approach
        â†“
ğŸª¨ STONE TOOLS    Raw fundamentals (variables, output, basic logic)
        â†“
ğŸªµ WOOD TOOLS     Structured basics (loops, conditionals, functions)
        â†“
ğŸ”© BRONZE TOOLS   Data organization (arrays, objects, strings)
        â†“
âš™ï¸ IRON TOOLS     Abstractions (callbacks, scope, error handling)
        â†“
ğŸ”§ STEEL TOOLS    Higher-order patterns (map, filter, reduce)
        â†“
âš¡ POWER TOOLS    Advanced concepts (async, recursion, generators)
        â†“
ğŸ¯ PRECISION      Competition-level mastery (algorithms, optimization)
```

### The Tool Refinement Metaphor

- **Blueprints** â†’ Understanding *why* before *how* â€” the mental models
- **Raw Tools** â†’ Foundational concepts that everything else is built upon
- **Refined Tools** â†’ Abstractions that emerge from mastering raw tools
- **Mastery** â†’ Knowing when to use the chisel vs the power saw

A developer doesn't just "learn loops" â€” they **forge** their loop tool through:
```
while (stone) â†’ for (wood) â†’ for...of (bronze) â†’ forEach (iron) â†’ map (steel) â†’ generators (power)
```

Each upgrade is **earned** through demonstrated understanding of the previous level.

---

## Three-Phase Lesson Structure

Every tool follows a **three-phase lesson progression**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“ PHASE 1: BLUEPRINT LESSONS (The WHY)                   â”‚
â”‚  Understanding the concept - language agnostic             â”‚
â”‚  Visual: Each lesson draws another line on the blueprint   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ”¨ PHASE 2: TOOL CRAFTING LESSONS (The HOW)               â”‚
â”‚  Building proficiency - hands-on practice                  â”‚
â”‚  Visual: Gathering materials, shaping, assembling          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ”© PHASE 3: MASTERY LESSONS (The COMPLETE)                â”‚
â”‚  Industry standards, cross-language syntax, best practices â”‚
â”‚  Visual: Each lesson hammers a nail, solidifying mastery   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why Three Phases?

| Phase | Focus | Feedback Type |
|-------|-------|---------------|
| **Blueprint** | Mental models, the WHY | "You understand when to use loops" |
| **Crafting** | Syntax & application | "Your loop syntax needs work" |
| **Mastery** | Patterns & transfer | "Try this pattern instead" |

### Granular Tracking Benefits

- **Precise diagnostics**: Know exactly which lesson caused confusion
- **Targeted code review**: "Review Blueprint Lesson 4: Off-by-one concept"
- **Progress visualization**: See the blueprint being drawn, tool being built
- **Cross-language awareness**: Mastery phase shows same tool in JS, Python, Go

---

## Tool Metaphor Library

Each coding tool maps to a **unique physical tool metaphor** that reflects its nature and progression:

### ğŸª¨ Stone Tier Tools

| Coding Tool | Metaphor | Progression |
|-------------|----------|-------------|
| **Variables** | ğŸ“¦ Container | Wooden box â†’ Labeled jar â†’ Smart storage bin |
| **Operators** | ğŸ“ Measuring | Hand span â†’ Ruler â†’ Laser measure |
| **Output** | ğŸ“¢ Communication | Chalk marks â†’ Whiteboard â†’ Digital display |
| **Input** | ğŸ‘‚ Receiver | Ear trumpet â†’ Telephone â†’ Voice assistant |

### ğŸªµ Wood Tier Tools

| Coding Tool | Metaphor | Progression |
|-------------|----------|-------------|
| **Conditionals** | ğŸšª Gate/Switch | Simple gate â†’ Locked door â†’ Smart lock |
| **For Loop** | ğŸ”„ Counting Wheel | Tally stick â†’ Abacus â†’ Mechanical counter |
| **While Loop** | âš™ï¸ Mill/Crank | Hand crank â†’ Water wheel â†’ Electric motor |

### ğŸ”© Bronze Tier Tools

| Coding Tool | Metaphor | Progression |
|-------------|----------|-------------|
| **Arrays** | ğŸ—„ï¸ Tool Rack | Simple hook â†’ Pegboard â†’ Automated carousel |
| **Objects** | ğŸ“‹ Blueprint Case | Sketch folder â†’ Drawing cabinet â†’ CAD system |
| **Strings** | ğŸ§µ Rope/Cord | Twine â†’ Braided rope â†’ Steel cable |

### âš™ï¸ Iron Tier Tools

| Coding Tool | Metaphor | Progression |
|-------------|----------|-------------|
| **Functions** | ğŸ› ï¸ Workbench | Simple table â†’ Full bench â†’ Modular station |
| **Scope** | ğŸ  Workshop | Open shed â†’ Divided rooms â†’ Sealed chambers |
| **Error Handling** | ğŸ›¡ï¸ Safety Gear | Gloves â†’ Goggles â†’ Full safety system |

### ğŸ”§ Steel Tier Tools

| Coding Tool | Metaphor | Progression |
|-------------|----------|-------------|
| **Map** | ğŸ­ Assembly Line | Hand assembly â†’ Conveyor â†’ Robotic arm |
| **Filter** | ğŸ” Sieve | Cloth strainer â†’ Wire mesh â†’ Precision filter |
| **Reduce** | ğŸ”¥ Forge | Campfire â†’ Furnace â†’ Industrial smelter |

### âš¡ Power Tier Tools

| Coding Tool | Metaphor | Progression |
|-------------|----------|-------------|
| **Async/Await** | âš¡ Power Grid | Candle â†’ Gas lamp â†’ Electric grid |
| **Recursion** | ğŸª† Nesting Dolls | Simple nesting â†’ Fractal â†’ Self-replicating |
| **Generators** | ğŸ’§ Pipeline | Bucket brigade â†’ Plumbing â†’ Flow system |

### ğŸ¯ Precision Tier Tools

| Coding Tool | Metaphor | Progression |
|-------------|----------|-------------|
| **Algorithms** | ğŸ¯ Precision Instrument | Compass â†’ Theodolite â†’ GPS |
| **Optimization** | âš–ï¸ Balance/Scale | Simple balance â†’ Triple beam â†’ Digital precision |
| **Data Structures** | ğŸ—ï¸ Architecture | Log cabin â†’ Frame house â†’ Skyscraper |

---

## Example: For Loop Full Lesson Map

```
FOR LOOP ğŸ”„ (Wood Tier - Counting Wheel Metaphor)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ BLUEPRINT PHASE: "Drawing the Counting Wheel Design"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
B1. Why Repetition? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [draws axle]
    â””â”€ Real-world: Stamps, assembly lines, counting inventory
    
B2. The Counting Pattern â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [draws first spoke]
    â””â”€ Start somewhere, stop somewhere, step each time
    
B3. Loop Anatomy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [draws wheel rim]
    â””â”€ Initialization, condition, increment - the three parts
    
B4. Boundary Thinking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [draws tick marks]
    â””â”€ Off-by-one: fencepost problem, < vs <=
    
B5. Loop vs Alternatives â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [draws gear teeth]
    â””â”€ When FOR, when WHILE, when MAP

ğŸ”¨ CRAFTING PHASE: "Building Your Counting Wheel"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
C1. First Rotation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [cut the axle]
    â””â”€ for (let i = 0; i < 5; i++) { console.log(i); }
    
C2. Counting Up â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [shape the hub]
    â””â”€ Exercises: count 1-10, 1-100, custom ranges
    
C3. Counting Down â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [add reverse gear]
    â””â”€ for (let i = 10; i > 0; i--) - countdowns, reverse iteration
    
C4. Custom Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [adjust spoke spacing]
    â””â”€ i += 2, i += 10 - skip counting, multiples
    
C5. Array Iteration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [attach to data belt]
    â””â”€ for (let i = 0; i < arr.length; i++)
    
C6. Nested Loops â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [build gear train]
    â””â”€ Loop within loop - grids, matrices, combinations
    
C7. Breaking Out â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [install brake]
    â””â”€ break, continue - early exit, skip iterations

ğŸ”© MASTERY PHASE: "Hardening the Tool"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
M1. Industry Patterns â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [ğŸ”¨ nail 1]
    â””â”€ Accumulator, search, transform patterns
    
M2. For vs ForEach vs Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [ğŸ”¨ nail 2]
    â””â”€ When to use which, performance implications
    
M3. Cross-Language Syntax â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [ğŸ”¨ nail 3]
    â””â”€ JS:     for (let i = 0; i < n; i++)
    â””â”€ Python: for i in range(n)
    â””â”€ Go:     for i := 0; i < n; i++
    â””â”€ Rust:   for i in 0..n
    
M4. Common Gotchas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [ğŸ”¨ nail 4]
    â””â”€ Mutation during iteration, closure traps, infinite loops
    
M5. Performance & When to Avoid â”€â”€â”€â”€â”€â”€â”€â”€ [ğŸ”¨ nail 5]
    â””â”€ Big O basics, when declarative is better

âœ¨ TOOL MASTERED: Counting Wheel Complete
```

---

## Documentation & Citations

### Citation Policy

**Every language syntax example MUST include a citation to official documentation.**

This ensures:
- Accuracy of syntax examples
- Users can deep-dive into official sources
- We maintain credibility and trust
- Easy verification and updates

### Official Documentation Sources

| Language | Primary Source | URL Pattern |
|----------|---------------|-------------|
| **JavaScript** | MDN Web Docs | `https://developer.mozilla.org/en-US/docs/Web/JavaScript/...` |
| **Python** | Python Official Docs | `https://docs.python.org/3/...` |
| **Go** | Go Tour / Go Docs | `https://go.dev/tour/...` or `https://go.dev/doc/...` |
| **TypeScript** | TypeScript Handbook | `https://www.typescriptlang.org/docs/...` |
| **Rust** | The Rust Book | `https://doc.rust-lang.org/book/...` |

### Citation Format in Lessons

```markdown
## Cross-Language Syntax

### JavaScript
\`\`\`javascript
for (let i = 0; i < n; i++) {
    // body
}
\`\`\`
ğŸ“– [MDN: for statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for)

### Python
\`\`\`python
for i in range(n):
    # body
\`\`\`
ğŸ“– [Python Docs: for Statements](https://docs.python.org/3/tutorial/controlflow.html#for-statements)

### Go
\`\`\`go
for i := 0; i < n; i++ {
    // body
}
\`\`\`
ğŸ“– [A Tour of Go: For](https://go.dev/tour/flowcontrol/1)
```

### Database Schema for Citations

```sql
language_docs (
    language_id   -- 'javascript', 'python', 'go'
    tool_id       -- 'for-loop', 'variables', etc.
    doc_url       -- Full URL to official docs
    doc_title     -- Page title for display
    doc_source    -- 'MDN', 'Python Docs', 'Go Docs'
    official_syntax -- Canonical syntax from docs
)
```

### Updating Documentation

When language versions change:
1. Verify existing doc_urls still work
2. Update official_syntax if changed
3. Add notes about version differences
4. Run automated link checker

---

## Tool-First, Language-Second Philosophy

### The Two Dimensions of Mastery

```
                        LANGUAGES
                   JS    Python    Go    Rust    ...
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    for-loop  â”‚  âš™ï¸      ğŸ”§       ğŸªµ      ğŸª¨        â”‚  
              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
T   while     â”‚  ğŸ”§      âš™ï¸       ğŸª¨      â€”         â”‚
O             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
O   map       â”‚  ğŸ”§      ğŸ”§       ğŸ”©      ğŸª¨        â”‚
L             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
S   filter    â”‚  âš™ï¸      ğŸ”§       ğŸ”©      â€”         â”‚
              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    reduce    â”‚  ğŸªµ      ğŸ”©       ğŸª¨      â€”         â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Tool Mastery** = Conceptual understanding (language-agnostic)
**Language Proficiency** = Syntax fluency in a specific language

### Learning Flow

```
1. UNDERSTAND THE TOOL (Concept)
   "What is a for loop? Why does it exist? When do I use it?"
   â””â”€â”€ Language-agnostic explanation with pseudocode
   
2. LEARN THE SYNTAX (Per Language)
   "How do I write a for loop in JavaScript?"
   â””â”€â”€ Language-specific syntax, idioms, gotchas
   
3. PRACTICE (Per Tool Ã— Language)
   "Complete exercises in your chosen language"
   â””â”€â”€ Exercises available in multiple languages
   
4. TRANSFER (Cross-Language)
   "Now try it in Python"
   â””â”€â”€ Leverage conceptual knowledge, learn new syntax
```

### Why This Matters

| Benefit | Description |
|---------|-------------|
| **Transferable Skills** | Understand loops ONCE, apply ANYWHERE |
| **Language Flexibility** | Learn new languages faster |
| **Clear Progress** | See exactly where you're strong/weak |
| **Future-Proof** | New languages slot in naturally |
| **Polyglot Support** | Track multi-language proficiency |

---

## Language Support Architecture

### Supported Languages (Current)

| Language | Tier | Status | Notes |
|----------|------|--------|-------|
| JavaScript | Primary | âœ… Full | Most examples, default |
| Python | Primary | âœ… Full | Second priority |
| Go | Secondary | âœ… Partial | Growing support |
| TypeScript | Secondary | ğŸ”² Planned | Extends JS |
| Rust | Tertiary | ğŸ”² Future | Community interest |
| Java | Tertiary | ğŸ”² Future | Enterprise demand |
| C# | Tertiary | ğŸ”² Future | Game dev, enterprise |

### Adding a New Language

To add a new language, create:

```
1. Language definition in constants
   - id: 'rust'
   - name: 'Rust'
   - icon: 'ğŸ¦€'
   - fileExtension: '.rs'
   - syntaxHighlight: 'rust'

2. Syntax examples for each tool
   - For each primitive, add syntax_template + full_example
   
3. Starter code for exercises
   - Each exercise needs starter_code + solution_code per language
   
4. Sandbox support (if code execution)
   - Runtime configuration
   - Security constraints
```

### Language-Specific Considerations

Each language may have:
- **Unique idioms** â€” Python list comprehensions, Go channels
- **Missing concepts** â€” Go has no while loop, only for
- **Different terminology** â€” dict vs object vs map
- **Syntax variations** â€” Arrow functions, lambdas, closures

These are captured in:
```
primitive_syntax.variations  â€” Language-specific alternatives
primitive_syntax.explanation â€” Language-specific context
```

---

## Scalable Data Model

### Core Entities

```
TOOLS (primitives)
  â”‚
  â”œâ”€â”€ LESSONS (per tool)
  â”‚     â””â”€â”€ Concept explanations, learning objectives
  â”‚
  â”œâ”€â”€ SYNTAX (per tool Ã— language)
  â”‚     â””â”€â”€ Language-specific examples
  â”‚
  â””â”€â”€ EXERCISES (per tool, available in multiple languages)
        â””â”€â”€ Exercise definitions with per-language starter/solution
```

### Progress Tracking (Three Levels)

```typescript
// 1. TOOL MASTERY (Conceptual - Language Agnostic)
interface ToolMastery {
  toolId: string;
  conceptLevel: 'stone' | 'wood' | 'bronze' | 'iron' | 'steel' | 'mastered';
  lessonsCompleted: number;
  lessonsTotal: number;
}

// 2. LANGUAGE PROFICIENCY (Per Tool Ã— Language)
interface ToolLanguageProficiency {
  toolId: string;
  language: string;
  syntaxLevel: 'stone' | 'wood' | 'bronze' | 'iron' | 'steel' | 'mastered';
  exercisesCompleted: number;
  exercisesTotal: number;
  averageScore: number;
  lastPracticed: Date;
}

// 3. OVERALL LANGUAGE SKILL (Aggregated)
interface LanguageSkill {
  language: string;
  toolsMastered: number;
  toolsTotal: number;
  overallLevel: number;  // Calculated from tool proficiencies
}
```

### Database Schema (Updated)

```sql
-- Languages table (for scalability)
CREATE TABLE languages (
    id TEXT PRIMARY KEY,           -- 'javascript', 'python', 'go'
    name TEXT NOT NULL,            -- 'JavaScript', 'Python', 'Go'
    display_order INTEGER DEFAULT 0,
    icon TEXT,                     -- emoji or icon class
    file_extension TEXT,           -- '.js', '.py', '.go'
    syntax_highlight TEXT,         -- Monaco/Prism language key
    sandbox_supported INTEGER DEFAULT 0,
    is_active INTEGER DEFAULT 1,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
);

-- Tool mastery (conceptual, language-agnostic)
CREATE TABLE user_tool_mastery (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    tool_id TEXT NOT NULL,
    concept_level TEXT DEFAULT 'stone',  -- Conceptual understanding
    lessons_completed INTEGER DEFAULT 0,
    lessons_total INTEGER DEFAULT 0,
    last_studied_at TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (tool_id) REFERENCES primitives(id),
    UNIQUE(user_id, tool_id)
);

-- Tool Ã— Language proficiency (syntax fluency)
CREATE TABLE user_tool_language_proficiency (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    tool_id TEXT NOT NULL,
    language_id TEXT NOT NULL,
    syntax_level TEXT DEFAULT 'stone',
    exercises_completed INTEGER DEFAULT 0,
    exercises_total INTEGER DEFAULT 0,
    total_attempts INTEGER DEFAULT 0,
    successful_attempts INTEGER DEFAULT 0,
    average_score REAL DEFAULT 0,
    best_score INTEGER DEFAULT 0,
    total_time_minutes INTEGER DEFAULT 0,
    last_practiced_at TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (tool_id) REFERENCES primitives(id),
    FOREIGN KEY (language_id) REFERENCES languages(id),
    UNIQUE(user_id, tool_id, language_id)
);

-- Overall language skill (aggregated view, can be computed or cached)
CREATE TABLE user_language_skill (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    language_id TEXT NOT NULL,
    tools_mastered INTEGER DEFAULT 0,  -- Tools at iron+ in this language
    tools_practiced INTEGER DEFAULT 0, -- Tools with any progress
    overall_level INTEGER DEFAULT 1,
    total_exercises INTEGER DEFAULT 0,
    total_xp INTEGER DEFAULT 0,
    last_active_at TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (language_id) REFERENCES languages(id),
    UNIQUE(user_id, language_id)
);
```

---

## Scalability Principles

### 1. Tool Definitions are Language-Agnostic

```yaml
# A tool definition (conceptual)
tool:
  id: for-loop
  name: For Loop
  category: control-flow
  tier: 2
  description: "Execute code a specific number of times..."
  # NO language-specific content here
```

### 2. Syntax is Attached Separately

```yaml
# Syntax attached per language
syntax:
  - tool_id: for-loop
    language: javascript
    template: "for (let i = 0; i < n; i++) { }"
    example: "for (let i = 0; i < 5; i++) { console.log(i); }"
    
  - tool_id: for-loop
    language: python
    template: "for i in range(n):"
    example: "for i in range(5):\n    print(i)"
    
  - tool_id: for-loop
    language: rust
    template: "for i in 0..n { }"
    example: "for i in 0..5 { println!(\"{}\", i); }"
```

### 3. Exercises Support Multiple Languages

```yaml
exercise:
  id: sum-to-n
  tool_id: for-loop
  title: "Sum of Numbers"
  description: "Calculate sum from 1 to n"
  # Exercise is conceptually the same
  
  starter_code:
    javascript: "function sumToN(n) {\n  // Your code\n}"
    python: "def sum_to_n(n):\n    # Your code\n    pass"
    go: "func sumToN(n int) int {\n    // Your code\n}"
    
  solution_code:
    javascript: "function sumToN(n) {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) sum += i;\n  return sum;\n}"
    python: "def sum_to_n(n):\n    total = 0\n    for i in range(1, n + 1):\n        total += i\n    return total"
    # etc.
```

### 4. Progress Rolls Up Naturally

```
User completes for-loop exercises in JavaScript
  â†’ user_tool_language_proficiency (for-loop, javascript) updated
  â†’ user_tool_mastery (for-loop) concept level may increase
  â†’ user_language_skill (javascript) aggregated totals updated

User then tries for-loop in Python
  â†’ New user_tool_language_proficiency (for-loop, python) created
  â†’ Conceptual mastery already high (transfers!)
  â†’ Just learning syntax (faster progression)
```

### 5. Adding New Languages is Additive

```sql
-- Add Rust support
INSERT INTO languages (id, name, icon, file_extension, syntax_highlight, sandbox_supported)
VALUES ('rust', 'Rust', 'ğŸ¦€', '.rs', 'rust', 0);

-- Add syntax for existing tools (can be gradual)
INSERT INTO primitive_syntax (primitive_id, language, syntax_template, ...)
VALUES ('for-loop', 'rust', 'for i in 0..n { }', ...);

-- Add starter code for existing exercises (can be gradual)
INSERT INTO exercise_starter_code (exercise_id, language, starter_code, solution_code)
VALUES ('sum-to-n', 'rust', 'fn sum_to_n(n: i32) -> i32 { }', '...');
```

### 6. Adding New Tools is Additive

```sql
-- Add a new tool
INSERT INTO primitives (id, name, category, tier, ...)
VALUES ('pattern-matching', 'Pattern Matching', 'control-flow', 6, ...);

-- Add lessons for the tool
INSERT INTO lessons (tool_id, slug, title, ...) VALUES 
('pattern-matching', 'what-is-pattern-matching', 'What is Pattern Matching?', ...),
('pattern-matching', 'match-syntax', 'Match Expression Syntax', ...);

-- Add syntax per language (some languages may not support it)
INSERT INTO primitive_syntax (primitive_id, language, ...) VALUES
('pattern-matching', 'rust', 'match value { ... }', ...),
('pattern-matching', 'python', 'match value: case ...', ...);
-- Note: JavaScript doesn't have native pattern matching (yet)
```

---

## Future Language Considerations

### Languages on the Horizon

| Language | Why | Timeline |
|----------|-----|----------|
| TypeScript | JS superset, enterprise adoption | Near-term |
| Rust | Systems, WebAssembly, safety focus | Medium-term |
| Kotlin | Android, modern JVM | Medium-term |
| Swift | iOS/macOS development | Medium-term |
| Zig | Low-level, growing interest | Long-term |
| Mojo | AI/ML focused Python superset | Long-term |

### Language Feature Matrix

Some tools only exist in certain languages:

| Tool | JS | Python | Go | Rust |
|------|----|----|----|----|
| for-loop | âœ… | âœ… | âœ… | âœ… |
| while-loop | âœ… | âœ… | âœ…* | âœ… |
| list-comprehension | âŒ | âœ… | âŒ | âŒ |
| pattern-matching | âŒ | âœ… | âŒ | âœ… |
| channels | âŒ | âŒ | âœ… | âŒ |
| ownership | âŒ | âŒ | âŒ | âœ… |

*Go uses `for` for everything

### Handling Language-Specific Tools

```yaml
tool:
  id: list-comprehension
  name: List Comprehension
  category: iteration
  tier: 5
  language_specific: true
  available_languages: ['python']
  related_tools: ['map', 'filter']  # For languages without this
  description: "Concise way to create lists from iterables"
```

When a tool isn't available in a user's preferred language:
> "List comprehensions are a Python-specific feature. In JavaScript, you'd use `map()` and `filter()` for similar results. [Learn map â†’](/learn/map)"

---

## Tool Anatomy: Lessons Within Tools

Every tool has its own **internal lesson progression**. This enables:
- Granular progress tracking per aspect
- Direct linking to specific lessons in code reviews
- Identifying exact knowledge gaps
- Building understanding systematically

### Lesson Structure Template

```
TOOL: {tool-id}
â”œâ”€â”€ Lesson 1: {concept} â€” Introduction, basic syntax
â”œâ”€â”€ Lesson 2: {concept} â€” Core use case
â”œâ”€â”€ Lesson 3: {concept} â€” Common patterns
â”œâ”€â”€ Lesson 4: {concept} â€” Edge cases & pitfalls
â”œâ”€â”€ Lesson 5: {concept} â€” Advanced usage
â””â”€â”€ Lesson 6: {concept} â€” Best practices & refinement
```

### Example: For Loop Lessons

```
TOOL: for-loop
â”œâ”€â”€ L1: syntax-basics        â€” The three parts: init, condition, update
â”œâ”€â”€ L2: counting             â€” Iterating a fixed number of times
â”œâ”€â”€ L3: array-iteration      â€” Looping through array indices
â”œâ”€â”€ L4: nested-loops         â€” Loops within loops
â”œâ”€â”€ L5: off-by-one           â€” Common boundary errors
â”œâ”€â”€ L6: loop-control         â€” Using break and continue
â”œâ”€â”€ L7: patterns             â€” Accumulator, counter, search patterns
â””â”€â”€ L8: optimization         â€” When to use for vs alternatives
```

**URL Structure:** `/learn/for-loop/off-by-one`
**Code Review Link:** "See [For Loop: Off-By-One Errors](/learn/for-loop/off-by-one)"

### Example: Arrays Lessons

```
TOOL: arrays
â”œâ”€â”€ L1: what-is-array        â€” Ordered collections concept
â”œâ”€â”€ L2: creating-arrays      â€” Declaration and initialization
â”œâ”€â”€ L3: accessing-elements   â€” Index-based access (arr[0])
â”œâ”€â”€ L4: modifying-elements   â€” Changing values at indices
â”œâ”€â”€ L5: array-length         â€” Using .length property
â”œâ”€â”€ L6: index-bounds         â€” Avoiding out-of-bounds errors
â”œâ”€â”€ L7: iterating-arrays     â€” Looping through arrays
â”œâ”€â”€ L8: common-methods       â€” push, pop, shift, unshift
â”œâ”€â”€ L9: slice-splice         â€” Extracting and modifying sections
â””â”€â”€ L10: searching           â€” indexOf, includes, find
```

### Example: Functions Lessons

```
TOOL: functions
â”œâ”€â”€ L1: what-is-function     â€” Reusable code blocks concept
â”œâ”€â”€ L2: defining-functions   â€” Function declaration syntax
â”œâ”€â”€ L3: calling-functions    â€” Invoking with parentheses
â”œâ”€â”€ L4: parameters           â€” Accepting inputs
â”œâ”€â”€ L5: arguments            â€” Passing values when calling
â”œâ”€â”€ L6: return-values        â€” Sending data back
â”œâ”€â”€ L7: scope-intro          â€” Variables inside vs outside
â”œâ”€â”€ L8: pure-functions       â€” No side effects concept
â”œâ”€â”€ L9: naming-conventions   â€” Verb-based, descriptive names
â””â”€â”€ L10: single-responsibility â€” One function, one job
```

### Lesson Difficulty Within a Tool

Lessons within a tool follow their own micro-progression:

| Lesson Position | Difficulty Modifier | Focus |
|-----------------|---------------------|-------|
| L1-L2 | Base | Syntax, basic concept |
| L3-L4 | Base + 0.5 | Core patterns, common usage |
| L5-L6 | Base + 1.0 | Edge cases, pitfalls |
| L7-L8 | Base + 1.5 | Advanced patterns |
| L9-L10 | Base + 2.0 | Best practices, optimization |

### Progress Tracking Per Lesson

```typescript
interface ToolProgress {
  toolId: string;
  overallMastery: 'stone' | 'wood' | 'bronze' | 'iron' | 'steel' | 'mastered';
  lessons: {
    [lessonId: string]: {
      status: 'locked' | 'available' | 'in_progress' | 'completed';
      completedAt?: Date;
      exercisesCompleted: number;
      exercisesTotal: number;
      bestScore: number;
      attempts: number;
    }
  }
}
```

### Unlocking Logic

- **L1** always available when tool is unlocked
- **L2+** requires previous lesson completed OR 70%+ score on assessment
- **Tool mastery level** = function of lessons completed + quality scores

### Code Review Integration

When reviewing user code, link directly to relevant lessons:

```markdown
**Issue:** Off-by-one error in your loop condition.

You wrote: `for (let i = 0; i <= arr.length; i++)`
Should be: `for (let i = 0; i < arr.length; i++)`

ğŸ“š Review: [For Loop: Off-By-One Errors](/learn/for-loop/off-by-one)
```

---

## The Complete Hierarchy

### TIER 0: ğŸ“ Blueprints (Pre-Programming)
*Understanding the workshop before picking up tools*

| Concept | Description | Time |
|---------|-------------|------|
| What is Code? | Instructions computers understand | 15 min |
| Sequential Execution | Code runs top to bottom | 15 min |
| Computational Thinking | Breaking problems into steps | 30 min |
| Pseudocode | Planning before coding | 20 min |

**No exercises â€” conceptual foundation only**

---

### TIER 1: ğŸª¨ Stone Tools (Foundational)
*Raw, essential implements â€” the first tools any craftsman learns*

| Tool ID | Name | Prereqs | Description |
|---------|------|---------|-------------|
| `output` | Output/Printing | - | Display results to the user |
| `comments` | Comments | - | Notes explaining code |
| `variables` | Variables | output | Named storage for values |
| `data-types` | Data Types | variables | Numbers, strings, booleans |
| `operators` | Operators | data-types | Math and comparison operations |

**Refinement Path:**
- `variables` â†’ `constants` â†’ `typed-variables` â†’ `destructuring`

**Exercises:** Basic, focused on syntax familiarity (5-10 per tool)

---

### TIER 2: ğŸªµ Wood Tools (Control Flow)
*Shaped and structured â€” deciding what to do and when*

| Tool ID | Name | Prereqs | Description |
|---------|------|---------|-------------|
| `conditionals` | Conditionals (if/else) | operators | Make decisions |
| `boolean-logic` | Boolean Logic | conditionals | AND, OR, NOT combinations |
| `switch` | Switch Statements | conditionals | Multiple discrete options |
| `ternary` | Ternary Operator | conditionals | Inline conditionals |
| `for-loop` | For Loop | variables, operators | Repeat N times |
| `while-loop` | While Loop | conditionals | Repeat until condition |
| `loop-control` | Break & Continue | for-loop, while-loop | Exit or skip iterations |

**Refinement Paths:**
- `conditionals` â†’ `ternary` â†’ `guard-clauses` â†’ `pattern-matching`
- `for-loop` â†’ `for-of` â†’ `forEach` â†’ `higher-order-iteration`

**Exercises:** Logic puzzles, counting problems, simple algorithms

---

### TIER 3: ğŸ”© Bronze Tools (Data Structures)
*Stronger, more durable â€” organizing your workspace*

| Tool ID | Name | Prereqs | Description |
|---------|------|---------|-------------|
| `arrays` | Arrays/Lists | for-loop | Ordered collections |
| `array-access` | Array Access & Modification | arrays | Reading and changing elements |
| `array-methods` | Array Methods | array-access, functions | push, pop, slice, etc. |
| `strings` | String Manipulation | arrays | Text as character collections |
| `objects` | Objects/Dictionaries | variables | Key-value pairs |
| `nested-structures` | Nested Data | arrays, objects | Complex data organization |

**Refinement Paths:**
- `arrays` â†’ `array-methods` â†’ `spread-operator` â†’ `destructuring`
- `objects` â†’ `object-methods` â†’ `optional-chaining` â†’ `computed-properties`

**Exercises:** Data transformation, search and filter, inventory systems

---

### TIER 4: âš™ï¸ Iron Tools (Functions)
*Reliable, versatile â€” tools that amplify effort*

| Tool ID | Name | Prereqs | Description |
|---------|------|---------|-------------|
| `functions` | Function Basics | variables | Define reusable code blocks |
| `parameters` | Parameters & Arguments | functions | Inputs to functions |
| `return-values` | Return Values | functions | Outputs from functions |
| `scope` | Scope | functions, variables | Variable visibility |
| `pure-functions` | Pure Functions | functions, scope | No side effects |
| `callbacks` | Callbacks | functions | Functions as arguments |
| `closures` | Closures | scope, callbacks | Functions remembering scope |

**Refinement Paths:**
- `functions` â†’ `arrow-functions` â†’ `higher-order-functions` â†’ `currying`
- `callbacks` â†’ `closures` â†’ `factory-functions` â†’ `module-pattern`

**Exercises:** Code organization, building utilities, event handling simulation

---

### TIER 5: ğŸ”§ Steel Tools (Iteration Mastery)
*Refined, precise â€” repeatable operations with elegance*

| Tool ID | Name | Prereqs | Description |
|---------|------|---------|-------------|
| `for-of` | For...of / For...in | for-loop, arrays | Iterate over values |
| `foreach` | forEach | arrays, callbacks | Functional iteration |
| `map` | Map | foreach | Transform every element |
| `filter` | Filter | foreach, conditionals | Select elements |
| `reduce` | Reduce | map, filter | Combine into single value |
| `chaining` | Method Chaining | map, filter | Compose operations |
| `find-some-every` | Find, Some, Every | filter | Search and validate |

**Refinement Paths:**
- `for-loop` â†’ `for-of` â†’ `forEach` â†’ `map/filter` â†’ `reduce`
- `reduce` â†’ `complex-reduce` â†’ `transducers`

**Exercises:** Data pipelines, statistics, search algorithms

---

### TIER 6: ğŸ›¡ï¸ Protective Gear (Error Handling)
*Safety equipment â€” protecting against the unexpected*

| Tool ID | Name | Prereqs | Description |
|---------|------|---------|-------------|
| `try-catch` | Try/Catch | functions | Handle runtime errors |
| `error-types` | Error Types | try-catch | Different error categories |
| `throwing` | Throwing Errors | try-catch | Creating errors intentionally |
| `validation` | Input Validation | conditionals, functions | Check before processing |
| `edge-cases` | Edge Case Handling | validation | Handle boundaries |
| `defensive-coding` | Defensive Programming | edge-cases | Assume nothing |

**Refinement Paths:**
- `try-catch` â†’ `specific-catches` â†’ `custom-errors` â†’ `result-types`

**Exercises:** Robust function writing, API response handling, user input

---

### TIER 7: ğŸ”¬ Specialized Tools (Advanced Data Structures)
*Purpose-built instruments for specific jobs*

| Tool ID | Name | Prereqs | Description |
|---------|------|---------|-------------|
| `set` | Sets | arrays | Unique value collections |
| `map-structure` | Map (data structure) | objects | Any-type key collections |
| `stack` | Stacks | arrays | LIFO operations |
| `queue` | Queues | arrays | FIFO operations |
| `linked-list` | Linked Lists | objects, classes | Node-based sequences |
| `tree-basics` | Trees | linked-list | Hierarchical structures |
| `graph-basics` | Graphs | tree-basics | Relationship networks |

**Key Insight:** Know WHAT â†’ Know WHEN â†’ Know WHY (Big O)

**Exercises:** Implement from scratch, then use built-ins, compare performance

---

### TIER 8: âš¡ Power Tools (Recursion & Algorithms)
*Electric, automated â€” building tools that build tools*

| Tool ID | Name | Prereqs | Description |
|---------|------|---------|-------------|
| `recursion-basics` | Recursion Fundamentals | functions, conditionals | Self-referential solutions |
| `base-cases` | Base Cases | recursion-basics | Termination conditions |
| `recursive-patterns` | Recursive Patterns | base-cases | Common recursive solutions |
| `memoization` | Memoization | recursion, closures | Cache results |
| `big-o` | Big O Notation | all above | Efficiency analysis |
| `divide-conquer` | Divide & Conquer | recursion | Binary search, merge sort |
| `backtracking` | Backtracking | recursion | Try all paths |

**Refinement Paths:**
- `brute-force` â†’ `recursion` â†’ `memoization` â†’ `dynamic-programming`

**Exercises:** Classic CS problems, optimization challenges

---

### TIER 9: ğŸ­ Industrial Machinery (Async & Concurrency)
*Assembly lines â€” parallel processing at scale*

| Tool ID | Name | Prereqs | Description |
|---------|------|---------|-------------|
| `callbacks-async` | Async Callbacks | callbacks | Non-blocking operations |
| `promises` | Promises | callbacks-async | Chainable async |
| `async-await` | Async/Await | promises | Readable async code |
| `promise-combinators` | Promise.all/race | promises | Parallel operations |
| `event-loop` | Event Loop | async-await | Understanding timing |
| `error-handling-async` | Async Error Handling | try-catch, async-await | Handling async failures |

**Refinement Paths:**
- `callbacks` â†’ `promises` â†’ `async-await` â†’ `reactive-streams`

**Exercises:** API calls, timers, concurrent operations

---

### TIER 10: ğŸ¯ Precision Instruments (Advanced Patterns)
*CNC, laser cutters â€” custom solutions with surgical precision*

| Tool ID | Name | Prereqs | Description |
|---------|------|---------|-------------|
| `generators` | Generators | iterators, functions | Lazy sequences |
| `iterators` | Custom Iterators | objects, generators | Protocol-based iteration |
| `decorators` | Decorators | higher-order-functions | Behavior modification |
| `proxies` | Proxies | objects | Operation interception |
| `symbols` | Symbols | objects | Unique identifiers |
| `metaprogramming` | Metaprogramming | all above | Code that writes code |

**Exercises:** Build frameworks, implement patterns from scratch

---

### TIER 11: ğŸ† Master Craftsman (Algorithm Mastery)
*Competition ready â€” speed, precision, creativity under pressure*

| Category | Techniques | Complexity |
|----------|------------|------------|
| Searching | Binary search, BFS, DFS, A* | Medium-Hard |
| Sorting | Quick, Merge, Heap, Radix | Medium |
| Dynamic Programming | Memoization, Tabulation | Hard |
| Graph Algorithms | Dijkstra, Topological Sort | Hard |
| String Algorithms | KMP, Tries, Edit Distance | Hard |

**Benchmark:** Advent of Code Days 1-15

---

### TIER 12: ğŸ‘‘ Grandmaster (Expert Problem Solving)
*Elite artisan â€” combining everything under constraint*

- Complex multi-step problems
- Novel problem decomposition
- Optimization under constraints
- Time/space tradeoffs
- Elegant, maintainable solutions

**Benchmark:** Advent of Code Days 16-25, LeetCode Hard

---

## Current Primitive Mapping

### âœ… Implemented (in seed data)

| Primitive | Current Tier | Target Tier | Status |
|-----------|--------------|-------------|--------|
| variables | 1 | TIER 1 | âœ… Correct |
| operators | 1 | TIER 1 | âœ… Correct |
| conditionals | 1 | TIER 2 | âš ï¸ Should be Tier 2 |
| for-loop | 2 | TIER 2 | âœ… Correct |
| while-loop | 2 | TIER 2 | âœ… Correct |
| functions | 2 | TIER 4 | âš ï¸ Should be Tier 4 |
| arrays | 2 | TIER 3 | âš ï¸ Should be Tier 3 |
| objects | 2 | TIER 3 | âš ï¸ Should be Tier 3 |

### ğŸ”² Missing (Priority Additions)

**Tier 0-1 (Foundations):**
- [ ] output
- [ ] comments
- [ ] data-types

**Tier 2 (Control Flow):**
- [ ] boolean-logic
- [ ] switch
- [ ] ternary
- [ ] loop-control (break/continue)

**Tier 3 (Data):**
- [ ] array-methods
- [ ] strings
- [ ] nested-structures

**Tier 4-5 (Functions & Iteration):**
- [ ] parameters (detailed)
- [ ] return-values (detailed)
- [ ] scope
- [ ] map
- [ ] filter
- [ ] reduce

---

## Difficulty Calculation

Difficulty is NOT arbitrary â€” it's calculated from **dependency depth**:

```
difficulty = max(prereq_difficulties) + 1
```

| Tier | Material | Base Difficulty | Example |
|------|----------|-----------------|---------|
| 0 | ğŸ“ Blueprints | 0 | Pre-programming concepts |
| 1 | ğŸª¨ Stone | 1 | Variables, output |
| 2 | ğŸªµ Wood | 2 | Loops, conditionals |
| 3 | ğŸ”© Bronze | 3 | Arrays, objects |
| 4 | âš™ï¸ Iron | 4 | Functions, scope |
| 5 | ğŸ”§ Steel | 5 | map/filter/reduce |
| 6 | ğŸ›¡ï¸ Protective | 6 | Error handling |
| 7 | ğŸ”¬ Specialized | 7 | Advanced data structures |
| 8 | âš¡ Power | 8 | Recursion, algorithms |
| 9 | ğŸ­ Industrial | 9 | Async/concurrency |
| 10 | ğŸ¯ Precision | 10 | Advanced patterns |
| 11 | ğŸ† Master | 10+ | Algorithm mastery |
| 12 | ğŸ‘‘ Grandmaster | 10+ | Elite problem solving |

---

## Tool Refinement System

### Visual Progression

Each tool has refinement stages with visual upgrades (matching the material metaphor):

```
ğŸª¨ STONE      â†’ First exposure, syntax learning
ğŸªµ WOOD       â†’ Completed 3+ exercises, getting comfortable
ğŸ”© BRONZE     â†’ Quality code, no hints needed
âš™ï¸ IRON       â†’ Can apply in novel situations
ğŸ”§ STEEL      â†’ Efficient, elegant solutions
âš¡ MASTERED   â†’ Understands edge cases, teaches others
```

### Quality Metrics for Refinement

1. **Exercises Completed** â€” Volume of practice
2. **First-Try Success Rate** â€” Understanding depth
3. **Hint Usage** â€” Independence level
4. **Code Quality Score** â€” Industry standards
   - Naming conventions
   - Proper indentation
   - No code smells
   - Efficient solutions
5. **Time to Solution** â€” Fluency

### Unlocking Refined Tools

Users don't see `map()` until they've demonstrated:
- âœ… `for-loop` at PROFICIENT level
- âœ… `arrays` at COMPETENT level
- âœ… `callbacks` at PRACTICED level

Then `map()` unlocks with explanation:
> "You've been writing this pattern manually. Here's the tool that does it for you."

---

## Badge Categories

### ğŸ› ï¸ Tool Mastery Badges
Earned by refining specific tools to mastery level

### ğŸ”¥ Streak Badges
Consistency over time (7, 14, 30, 100, 365 days)

### ğŸ† Milestone Badges
Volume achievements (1, 5, 25, 100, 500 exercises)

### ğŸ¯ Skill Badges
Special accomplishments (no hints, speed runs, first-try perfects)

### ğŸŒŸ Tier Badges
Completing all tools in a tier

### ğŸ‘‘ Elite Badges
Competition-level achievements (AoC completion, etc.)

---

## Implementation Priorities

### Phase 1: Foundation (Current â†’ +2 weeks)
1. Update existing primitives with correct tiers
2. Add Tier 0-1 missing primitives
3. Implement prerequisite enforcement

### Phase 2: Control & Data (+2-4 weeks)
1. Add Tier 2-3 primitives
2. Create 5+ exercises per primitive
3. Implement basic refinement tracking

### Phase 3: Functions & Iteration (+4-8 weeks)
1. Add Tier 4-5 primitives
2. Implement quality scoring
3. Add tool unlocking system

### Phase 4: Advanced (+8-16 weeks)
1. Add Tier 6-10 progressively
2. Competition track (Tier 11-12)
3. Full refinement visualization

---

## Content Guidelines

### Every Primitive Needs:

1. **Clear Definition** â€” What is this tool?
2. **Why It Matters** â€” When/why would you use it?
3. **Syntax per Language** â€” JS, Python, Go (minimum)
4. **Best Practices** â€” Industry standards
5. **Common Pitfalls** â€” What trips people up
6. **Prerequisites** â€” What must be understood first
7. **Refinement Path** â€” What does this tool lead to?
8. **5-10 Exercises** â€” Progressive difficulty within the tool

### Exercise Quality Standards:

- **Clear Instructions** â€” No ambiguity
- **Real-World Context** â€” Why would someone do this?
- **Test Cases** â€” Comprehensive, including edge cases
- **Progressive Hints** â€” Nudge, don't solve
- **Solution Explanation** â€” Not just code, but WHY

---

---

## Complete Lesson Maps

### TIER 1: ğŸª¨ Stone Tools â€” Lesson Breakdowns

#### `output` (Output/Printing)
```
â”œâ”€â”€ L1: why-output           â€” Seeing what your code does
â”œâ”€â”€ L2: print-syntax         â€” console.log / print / fmt.Println
â”œâ”€â”€ L3: printing-variables   â€” Displaying stored values
â”œâ”€â”€ L4: string-concatenation â€” Combining text and variables
â”œâ”€â”€ L5: template-literals    â€” Modern string interpolation
â””â”€â”€ L6: debugging-output     â€” Using print for debugging
```

#### `comments` (Code Comments)
```
â”œâ”€â”€ L1: why-comments         â€” Code documentation purpose
â”œâ”€â”€ L2: single-line          â€” // and # syntax
â”œâ”€â”€ L3: multi-line           â€” /* */ and """ """ syntax
â”œâ”€â”€ L4: when-to-comment      â€” What deserves a comment
â”œâ”€â”€ L5: self-documenting     â€” Code that explains itself
â””â”€â”€ L6: comment-antipatterns â€” Comments that hurt readability
```

#### `variables` (Variables)
```
â”œâ”€â”€ L1: what-is-variable     â€” Named storage concept
â”œâ”€â”€ L2: declaration          â€” Creating variables (let, const, var)
â”œâ”€â”€ L3: assignment           â€” Storing values
â”œâ”€â”€ L4: reassignment         â€” Changing values
â”œâ”€â”€ L5: naming-conventions   â€” camelCase, snake_case, CONSTANTS
â”œâ”€â”€ L6: const-vs-let         â€” When to use each
â”œâ”€â”€ L7: initialization       â€” Declaring with initial values
â””â”€â”€ L8: scope-preview        â€” Where variables exist
```

#### `data-types` (Data Types)
```
â”œâ”€â”€ L1: what-are-types       â€” Different kinds of data
â”œâ”€â”€ L2: numbers              â€” Integers and floats
â”œâ”€â”€ L3: strings              â€” Text data
â”œâ”€â”€ L4: booleans             â€” True/false values
â”œâ”€â”€ L5: type-checking        â€” typeof, type(), reflect
â”œâ”€â”€ L6: type-coercion        â€” Automatic conversion pitfalls
â”œâ”€â”€ L7: null-undefined       â€” Absence of value
â””â”€â”€ L8: choosing-types       â€” Which type for which situation
```

#### `operators` (Operators)
```
â”œâ”€â”€ L1: what-are-operators   â€” Symbols that transform values
â”œâ”€â”€ L2: arithmetic           â€” + - * / % **
â”œâ”€â”€ L3: comparison           â€” == === != < > <= >=
â”œâ”€â”€ L4: logical              â€” && || !
â”œâ”€â”€ L5: assignment-ops       â€” += -= *= /=
â”œâ”€â”€ L6: precedence           â€” Order of operations
â”œâ”€â”€ L7: equality-gotchas     â€” == vs === pitfalls
â””â”€â”€ L8: short-circuit        â€” && and || evaluation tricks
```

---

### TIER 2: ğŸªµ Wood Tools â€” Lesson Breakdowns

#### `conditionals` (If/Else)
```
â”œâ”€â”€ L1: what-is-conditional  â€” Making decisions in code
â”œâ”€â”€ L2: if-statement         â€” Single condition checks
â”œâ”€â”€ L3: if-else              â€” Two-path decisions
â”œâ”€â”€ L4: else-if              â€” Multiple conditions
â”œâ”€â”€ L5: nested-conditionals  â€” Conditions within conditions
â”œâ”€â”€ L6: truthy-falsy         â€” What counts as true/false
â”œâ”€â”€ L7: guard-clauses        â€” Early returns for cleaner code
â””â”€â”€ L8: refactoring-ifs      â€” Simplifying complex conditions
```

#### `boolean-logic` (Boolean Logic)
```
â”œâ”€â”€ L1: and-operator         â€” Both must be true
â”œâ”€â”€ L2: or-operator          â€” Either can be true
â”œâ”€â”€ L3: not-operator         â€” Inverting boolean values
â”œâ”€â”€ L4: combining-operators  â€” Complex conditions
â”œâ”€â”€ L5: de-morgans-law       â€” Logical equivalences
â”œâ”€â”€ L6: truthiness-tables    â€” Visualizing logic
â””â”€â”€ L7: readable-conditions  â€” Writing clear boolean expressions
```

#### `for-loop` (For Loop)
```
â”œâ”€â”€ L1: why-loops            â€” Repeating without copy-paste
â”œâ”€â”€ L2: for-syntax           â€” init; condition; update
â”œâ”€â”€ L3: counting-up          â€” i = 0; i < n; i++
â”œâ”€â”€ L4: counting-down        â€” Reverse iteration
â”œâ”€â”€ L5: step-values          â€” i += 2, i += 10
â”œâ”€â”€ L6: array-iteration      â€” Looping through indices
â”œâ”€â”€ L7: nested-loops         â€” Loops within loops
â”œâ”€â”€ L8: off-by-one           â€” <= vs < boundary errors
â”œâ”€â”€ L9: break-continue       â€” Exiting and skipping
â””â”€â”€ L10: loop-patterns       â€” Accumulator, search, transform
```

#### `while-loop` (While Loop)
```
â”œâ”€â”€ L1: while-vs-for         â€” When iteration count is unknown
â”œâ”€â”€ L2: while-syntax         â€” while (condition) { }
â”œâ”€â”€ L3: infinite-loops       â€” Danger and intentional use
â”œâ”€â”€ L4: loop-variables       â€” Updating condition variables
â”œâ”€â”€ L5: do-while             â€” Execute at least once
â”œâ”€â”€ L6: sentinel-values      â€” Loop until special value
â””â”€â”€ L7: while-patterns       â€” Input validation, polling
```

#### `switch` (Switch Statements)
```
â”œâ”€â”€ L1: when-switch          â€” Multiple discrete values
â”œâ”€â”€ L2: switch-syntax        â€” case, break, default
â”œâ”€â”€ L3: fall-through         â€” Intentional and accidental
â”œâ”€â”€ L4: grouping-cases       â€” Multiple cases, same action
â”œâ”€â”€ L5: switch-vs-if         â€” When to use each
â””â”€â”€ L6: switch-expressions   â€” Modern switch patterns
```

#### `ternary` (Ternary Operator)
```
â”œâ”€â”€ L1: ternary-syntax       â€” condition ? yes : no
â”œâ”€â”€ L2: simple-assignments   â€” Choosing between two values
â”œâ”€â”€ L3: nested-ternary       â€” Why to avoid (usually)
â”œâ”€â”€ L4: ternary-vs-if        â€” Readability tradeoffs
â””â”€â”€ L5: ternary-patterns     â€” Default values, toggles
```

---

### TIER 3: ğŸ”© Bronze Tools â€” Lesson Breakdowns

#### `arrays` (Arrays/Lists)
```
â”œâ”€â”€ L1: what-is-array        â€” Ordered collections
â”œâ”€â”€ L2: creating-arrays      â€” Literal and constructor
â”œâ”€â”€ L3: accessing-elements   â€” arr[index]
â”œâ”€â”€ L4: modifying-elements   â€” arr[index] = value
â”œâ”€â”€ L5: array-length         â€” .length property
â”œâ”€â”€ L6: index-bounds         â€” Out-of-bounds errors
â”œâ”€â”€ L7: iterating            â€” Looping through arrays
â”œâ”€â”€ L8: push-pop             â€” Adding/removing from end
â”œâ”€â”€ L9: shift-unshift        â€” Adding/removing from start
â”œâ”€â”€ L10: slice               â€” Extracting portions
â”œâ”€â”€ L11: splice              â€” Modifying in place
â”œâ”€â”€ L12: spread-operator     â€” [...arr] spreading
â””â”€â”€ L13: destructuring       â€” const [a, b] = arr
```

#### `objects` (Objects/Dictionaries)
```
â”œâ”€â”€ L1: what-is-object       â€” Key-value collections
â”œâ”€â”€ L2: creating-objects     â€” Literal syntax { }
â”œâ”€â”€ L3: accessing-properties â€” dot and bracket notation
â”œâ”€â”€ L4: modifying-properties â€” Adding and changing
â”œâ”€â”€ L5: deleting-properties  â€” Removing keys
â”œâ”€â”€ L6: checking-existence   â€” in operator, hasOwnProperty
â”œâ”€â”€ L7: iterating-objects    â€” for...in, Object.keys/values
â”œâ”€â”€ L8: nested-objects       â€” Objects within objects
â”œâ”€â”€ L9: object-methods       â€” Functions as properties
â”œâ”€â”€ L10: spread-operator     â€” {...obj} spreading
â”œâ”€â”€ L11: destructuring       â€” const { a, b } = obj
â””â”€â”€ L12: optional-chaining   â€” obj?.prop?.nested
```

#### `strings` (String Manipulation)
```
â”œâ”€â”€ L1: string-basics        â€” Text as data
â”œâ”€â”€ L2: string-length        â€” .length property
â”œâ”€â”€ L3: accessing-chars      â€” str[index]
â”œâ”€â”€ L4: concatenation        â€” Joining strings
â”œâ”€â”€ L5: template-literals    â€” ${variable} interpolation
â”œâ”€â”€ L6: case-conversion      â€” toUpperCase, toLowerCase
â”œâ”€â”€ L7: searching            â€” indexOf, includes
â”œâ”€â”€ L8: extracting           â€” slice, substring
â”œâ”€â”€ L9: splitting            â€” str.split(delimiter)
â”œâ”€â”€ L10: joining             â€” arr.join(delimiter)
â”œâ”€â”€ L11: trimming            â€” trim, trimStart, trimEnd
â””â”€â”€ L12: replacing           â€” replace, replaceAll
```

---

### TIER 4: âš™ï¸ Iron Tools â€” Lesson Breakdowns

#### `functions` (Functions)
```
â”œâ”€â”€ L1: why-functions        â€” Reusability and organization
â”œâ”€â”€ L2: function-declaration â€” function name() { }
â”œâ”€â”€ L3: function-expression  â€” const fn = function() { }
â”œâ”€â”€ L4: arrow-functions      â€” const fn = () => { }
â”œâ”€â”€ L5: calling-functions    â€” fn() invocation
â”œâ”€â”€ L6: parameters           â€” Accepting inputs
â”œâ”€â”€ L7: arguments            â€” Passing values
â”œâ”€â”€ L8: default-parameters   â€” Default values for params
â”œâ”€â”€ L9: rest-parameters      â€” ...args collecting
â”œâ”€â”€ L10: return-values       â€” Sending data back
â”œâ”€â”€ L11: early-return        â€” Returning early for clarity
â”œâ”€â”€ L12: void-functions      â€” Functions with no return
â”œâ”€â”€ L13: naming-conventions  â€” Verb-based names
â””â”€â”€ L14: documentation       â€” JSDoc, docstrings
```

#### `scope` (Variable Scope)
```
â”œâ”€â”€ L1: what-is-scope        â€” Where variables exist
â”œâ”€â”€ L2: global-scope         â€” Accessible everywhere
â”œâ”€â”€ L3: function-scope       â€” Inside function only
â”œâ”€â”€ L4: block-scope          â€” let/const in { }
â”œâ”€â”€ L5: scope-chain          â€” Looking up the chain
â”œâ”€â”€ L6: shadowing            â€” Same name, different scope
â”œâ”€â”€ L7: var-vs-let           â€” Scope differences
â””â”€â”€ L8: avoiding-globals     â€” Why globals are risky
```

#### `callbacks` (Callback Functions)
```
â”œâ”€â”€ L1: functions-as-values  â€” Passing functions around
â”œâ”€â”€ L2: callback-concept     â€” "Call me back when done"
â”œâ”€â”€ L3: synchronous-callbacks â€” Array methods, event handlers
â”œâ”€â”€ L4: callback-parameters  â€” Understanding callback args
â”œâ”€â”€ L5: anonymous-callbacks  â€” Inline function definitions
â”œâ”€â”€ L6: arrow-callbacks      â€” () => syntax in callbacks
â”œâ”€â”€ L7: callback-patterns    â€” Error-first, completion
â””â”€â”€ L8: callback-hell        â€” Why nesting gets messy
```

#### `closures` (Closures)
```
â”œâ”€â”€ L1: closure-concept      â€” Functions remember their scope
â”œâ”€â”€ L2: lexical-scope        â€” Where function was defined
â”œâ”€â”€ L3: closure-examples     â€” Counter, private variables
â”œâ”€â”€ L4: factory-functions    â€” Functions that make functions
â”œâ”€â”€ L5: data-privacy         â€” Hiding implementation details
â”œâ”€â”€ L6: closure-gotchas      â€” Loop variable capture
â””â”€â”€ L7: practical-closures   â€” Event handlers, memoization
```

---

### TIER 5: ğŸ”§ Steel Tools â€” Lesson Breakdowns

#### `map` (Array Map)
```
â”œâ”€â”€ L1: map-concept          â€” Transform every element
â”œâ”€â”€ L2: map-syntax           â€” arr.map(fn)
â”œâ”€â”€ L3: callback-arguments   â€” element, index, array
â”œâ”€â”€ L4: returning-values     â€” What to return
â”œâ”€â”€ L5: chaining-map         â€” map().map()
â”œâ”€â”€ L6: map-vs-foreach       â€” When to use each
â”œâ”€â”€ L7: object-mapping       â€” Transforming object arrays
â””â”€â”€ L8: map-patterns         â€” Extract, convert, compute
```

#### `filter` (Array Filter)
```
â”œâ”€â”€ L1: filter-concept       â€” Select matching elements
â”œâ”€â”€ L2: filter-syntax        â€” arr.filter(fn)
â”œâ”€â”€ L3: predicate-functions  â€” Returning true/false
â”œâ”€â”€ L4: filter-conditions    â€” Complex filtering
â”œâ”€â”€ L5: chaining-filter      â€” filter().map()
â”œâ”€â”€ L6: filter-vs-find       â€” All matches vs first match
â””â”€â”€ L7: filter-patterns      â€” Search, validate, exclude
```

#### `reduce` (Array Reduce)
```
â”œâ”€â”€ L1: reduce-concept       â€” Combine into single value
â”œâ”€â”€ L2: reduce-syntax        â€” arr.reduce(fn, initial)
â”œâ”€â”€ L3: accumulator          â€” The running result
â”œâ”€â”€ L4: sum-example          â€” Classic reduce use
â”œâ”€â”€ L5: object-building      â€” Reducing to objects
â”œâ”€â”€ L6: flatten              â€” Reducing nested arrays
â”œâ”€â”€ L7: reduce-vs-loop       â€” When reduce shines
â””â”€â”€ L8: reduce-patterns      â€” Group, count, transform
```

---

## Complete Database Schema (Scalable)

All tables needed to support Tool Ã— Language Ã— Lesson architecture:

```sql
-- ============================================
-- LANGUAGES (Scalable language support)
-- ============================================

CREATE TABLE languages (
    id TEXT PRIMARY KEY,              -- 'javascript', 'python', 'go', 'rust'
    name TEXT NOT NULL,               -- 'JavaScript', 'Python', 'Go', 'Rust'
    display_order INTEGER DEFAULT 0,  -- Sort order in UI
    icon TEXT,                        -- Emoji or icon class
    file_extension TEXT,              -- '.js', '.py', '.go', '.rs'
    syntax_highlight TEXT,            -- Monaco/Prism language key
    sandbox_supported INTEGER DEFAULT 0,
    is_primary INTEGER DEFAULT 0,     -- Primary languages shown first
    is_active INTEGER DEFAULT 1,      -- Can be disabled without deletion
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
);

-- Seed primary languages
INSERT INTO languages (id, name, display_order, icon, file_extension, syntax_highlight, sandbox_supported, is_primary, is_active, created_at, updated_at)
VALUES 
('javascript', 'JavaScript', 1, 'ğŸŸ¨', '.js', 'javascript', 1, 1, 1, datetime('now'), datetime('now')),
('python', 'Python', 2, 'ğŸ', '.py', 'python', 0, 1, 1, datetime('now'), datetime('now')),
('go', 'Go', 3, 'ğŸ¹', '.go', 'go', 0, 0, 1, datetime('now'), datetime('now')),
('typescript', 'TypeScript', 4, 'ğŸ”·', '.ts', 'typescript', 0, 0, 0, datetime('now'), datetime('now')),
('rust', 'Rust', 5, 'ğŸ¦€', '.rs', 'rust', 0, 0, 0, datetime('now'), datetime('now'));

-- ============================================
-- LESSONS (Per Tool)
-- ============================================

CREATE TABLE lessons (
    id TEXT PRIMARY KEY,
    tool_id TEXT NOT NULL,
    slug TEXT NOT NULL,               -- URL-safe: 'off-by-one', 'for-syntax'
    title TEXT NOT NULL,              -- 'Off-By-One Errors'
    description TEXT NOT NULL,        -- Brief description for listings
    sequence_order INTEGER NOT NULL,  -- L1, L2, L3...
    difficulty_modifier REAL DEFAULT 0, -- Added to tool base difficulty
    content_markdown TEXT,            -- Lesson content (conceptual)
    estimated_minutes INTEGER DEFAULT 10,
    is_premium INTEGER DEFAULT 0,
    is_published INTEGER DEFAULT 1,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY (tool_id) REFERENCES primitives(id),
    UNIQUE(tool_id, slug)
);

CREATE INDEX idx_lessons_tool ON lessons(tool_id);
CREATE INDEX idx_lessons_published ON lessons(is_published);

-- ============================================
-- USER PROGRESS: Tool Mastery (Conceptual)
-- ============================================

CREATE TABLE user_tool_mastery (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    tool_id TEXT NOT NULL,
    concept_level TEXT DEFAULT 'stone',  -- stone, wood, bronze, iron, steel, mastered
    lessons_completed INTEGER DEFAULT 0,
    lessons_total INTEGER DEFAULT 0,
    last_studied_at TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (tool_id) REFERENCES primitives(id),
    UNIQUE(user_id, tool_id)
);

CREATE INDEX idx_tool_mastery_user ON user_tool_mastery(user_id);

-- ============================================
-- USER PROGRESS: Tool Ã— Language Proficiency
-- ============================================

CREATE TABLE user_tool_language_proficiency (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    tool_id TEXT NOT NULL,
    language_id TEXT NOT NULL,
    syntax_level TEXT DEFAULT 'stone',   -- Proficiency in this language
    exercises_completed INTEGER DEFAULT 0,
    exercises_total INTEGER DEFAULT 0,
    total_attempts INTEGER DEFAULT 0,
    successful_attempts INTEGER DEFAULT 0,
    average_score REAL DEFAULT 0,
    best_score INTEGER DEFAULT 0,
    total_time_minutes INTEGER DEFAULT 0,
    last_practiced_at TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (tool_id) REFERENCES primitives(id),
    FOREIGN KEY (language_id) REFERENCES languages(id),
    UNIQUE(user_id, tool_id, language_id)
);

CREATE INDEX idx_tool_lang_prof_user ON user_tool_language_proficiency(user_id);
CREATE INDEX idx_tool_lang_prof_tool ON user_tool_language_proficiency(tool_id);
CREATE INDEX idx_tool_lang_prof_lang ON user_tool_language_proficiency(language_id);

-- ============================================
-- USER PROGRESS: Lesson Progress
-- ============================================

CREATE TABLE user_lesson_progress (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    lesson_id TEXT NOT NULL,
    status TEXT DEFAULT 'locked',      -- locked, available, in_progress, completed
    started_at TEXT,
    completed_at TEXT,
    exercises_completed INTEGER DEFAULT 0,
    exercises_total INTEGER DEFAULT 0,
    best_score INTEGER,
    attempts INTEGER DEFAULT 0,
    time_spent_minutes INTEGER DEFAULT 0,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (lesson_id) REFERENCES lessons(id),
    UNIQUE(user_id, lesson_id)
);

CREATE INDEX idx_lesson_progress_user ON user_lesson_progress(user_id);

-- ============================================
-- USER PROGRESS: Overall Language Skill
-- ============================================

CREATE TABLE user_language_skill (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    language_id TEXT NOT NULL,
    tools_mastered INTEGER DEFAULT 0,   -- Tools at iron+ level
    tools_practiced INTEGER DEFAULT 0,  -- Tools with any progress
    overall_level INTEGER DEFAULT 1,    -- Aggregated level
    total_exercises INTEGER DEFAULT 0,
    total_xp INTEGER DEFAULT 0,
    last_active_at TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (language_id) REFERENCES languages(id),
    UNIQUE(user_id, language_id)
);

CREATE INDEX idx_lang_skill_user ON user_language_skill(user_id);

-- ============================================
-- LANGUAGE-SPECIFIC TOOL AVAILABILITY
-- (For tools that only exist in some languages)
-- ============================================

CREATE TABLE tool_language_support (
    id TEXT PRIMARY KEY,
    tool_id TEXT NOT NULL,
    language_id TEXT NOT NULL,
    is_supported INTEGER DEFAULT 1,      -- 1 = supported, 0 = not available
    alternative_tool_id TEXT,            -- If not supported, suggest this instead
    notes TEXT,                          -- "Use map() instead in JavaScript"
    created_at TEXT NOT NULL,
    FOREIGN KEY (tool_id) REFERENCES primitives(id),
    FOREIGN KEY (language_id) REFERENCES languages(id),
    FOREIGN KEY (alternative_tool_id) REFERENCES primitives(id),
    UNIQUE(tool_id, language_id)
);
```

---

## URL Structure

```
/learn                           â†’ Tool catalog
/learn/{tool}                    â†’ Tool overview + lesson list
/learn/{tool}/{lesson}           â†’ Specific lesson content
/learn/{tool}/{lesson}/exercises â†’ Exercises for this lesson

Examples:
/learn/for-loop                  â†’ For Loop overview
/learn/for-loop/off-by-one       â†’ Off-by-one errors lesson
/learn/for-loop/off-by-one/exercises â†’ Practice exercises
```

---

## Maintenance

This document is the **source of truth** for curriculum structure. Any changes to:
- Primitive organization
- Difficulty ratings
- Prerequisite chains
- Tier assignments

Must be reflected here first, then implemented in code/database.

**Last Updated:** January 6, 2026
**Version:** 1.0
